// Generated by CoffeeScript 1.9.0
(function() {
  var AUTHORIZED_PATH, DEFAULT_EXTENSION, DEFAULT_PROTOCOL, FIRST_LINE_REGEX, METHOD_REGEX, ROOT, ServerOptions, contentTypeMap, createErrorHtml, createResponseHeader, extractStatusLine, fs, net, path, sendResponse, server, statusMessages;

  fs = require('fs');

  net = require('net');

  path = require('path');

  ROOT = __dirname + '/webroot';

  DEFAULT_PROTOCOL = 'HTTP/1.0';

  DEFAULT_EXTENSION = '.html';

  FIRST_LINE_REGEX = new RegExp("(GET|POST|HEAD)[ ]([\/].*[ ]){1,}HTTP\/1\.[0-9]");

  AUTHORIZED_PATH = new RegExp(ROOT + ".*");

  METHOD_REGEX = new RegExp("(GET|POST|HEAD)");

  statusMessages = {
    200: "OK",
    201: "Created",
    202: "Accepted",
    204: "No Content",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable"
  };

  contentTypeMap = {
    '.jpg': 'image/jpg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.bmp': 'image/bmp',
    '.gif': 'image/gif',
    '.js': 'application/javascript',
    '.mp4': 'video/mp4',
    '.mp3': 'audio/mp3',
    '.html': 'text/html',
    '.css': 'text/css'
  };

  createErrorHtml = function(code) {
    return {
      body: "<!DOCTYPE html> <html> <head> <title>Webserver Test</title> <meta charset='utf-8'> </head> <body> <H2>" + code + " " + statusMessages[code] + "</H2> </body> </html>"
    };
  };

  extractStatusLine = function(data) {
    var firstLine, requestLineArray, requestLineJSON;
    firstLine = (data.toString().split("\r\n"))[0];
    if (FIRST_LINE_REGEX.test(firstLine)) {
      requestLineArray = firstLine.split(" ");
      requestLineJSON = {
        "method": requestLineArray[0],
        "path": requestLineArray[1] === '/' ? 'index.html' : requestLineArray[1],
        "protocol": requestLineArray[2]
      };
      return requestLineJSON;
    }
    return null;
  };

  createResponseHeader = function(code, ext, fileLength) {
    var responseHeader;
    responseHeader = {};
    responseHeader["_statusLine"] = DEFAULT_PROTOCOL + " " + code + " " + statusMessages[code];
    responseHeader['content-Type'] = ext && contentTypeMap[ext] ? contentTypeMap[ext] : 'text/plain';
    if (fileLength) {
      responseHeader['Content-Length'] = fileLength;
    } else {
      responseHeader['Content-Length'] = 0;
    }
    responseHeader['Connection'] = 'close';
    return {
      toString: function() {
        var i, str, v;
        str = "";
        for (i in responseHeader) {
          v = responseHeader[i];
          if ((i.substring(0, 1)) === '_') {
            str += v + "\r\n";
          } else {
            str += i + ': ' + v + "\r\n";
          }
        }
        return str + '\r\n';
      }
    };
  };

  sendResponse = function(socket, header, statusCode, readStream) {
    return socket.write(header.toString(), function() {
      if (readStream) {
        return readStream.pipe(socket);
      } else {
        socket.write((createErrorHtml(statusCode))['body'] + '\n');
        return socket.end();
      }
    });
  };

  ServerOptions = {
    allowHalfOpen: false,
    pauseOnConnect: false
  };

  server = net.createServer(ServerOptions, function(socket) {
    socket.on('connection', function() {
      return console.log('socket : connect');
    });
    return socket.on('data', function(data) {
      var absolutePath, extension, requestLineHeader, responseHeader, statusCode;
      statusCode = 400;
      requestLineHeader = extractStatusLine(data);
      if (requestLineHeader) {
        absolutePath = path.join(ROOT, requestLineHeader['path']);
        console.log(absolutePath);
        extension = path.extname(absolutePath.toLowerCase());
        fs.stat(absolutePath, function(err, stats) {
          var fileSize, readStream, responseHeader;
          if (err) {
            statusCode = 404;
          } else if (stats.isDirectory() || !AUTHORIZED_PATH.test(absolutePath)) {
            statusCode = 403;
          } else if (stats.isFile()) {
            statusCode = 200;
            fileSize = stats["size"];
            readStream = fs.createReadStream(absolutePath);
            readStream.on('end', function() {
              return socket.end();
            });
          }
          if (!fileSize) {
            fileSize = Buffer.byteLength((createErrorHtml(statusCode))['body'], 'utf8');
          }
          responseHeader = createResponseHeader(statusCode, extension, fileSize);
          return sendResponse(socket, responseHeader, statusCode, readStream);
        });
      } else {
        responseHeader = createResponseHeader(statusCode);
        sendResponse(socket, responseHeader, statusCode);
      }
      socket.on('error', function(err) {
        return console.log('socket: error', err);
      });
      return socket.on('close', function() {});
    });
  });

  server.listen(9000, 'localhost');

}).call(this);
