// Generated by CoffeeScript 1.9.0
(function() {
  var AUTHORIZED_PATH, DEFAULT_EXTENSION, DEFAULT_PROTOCOL, FIRST_LINE_REGEX, METHOD_REGEX, ROOT, ServerOptions, contentTypeMap, createErrorHtml, createResponseHeader, fs, net, obj, parseStatusLine, path, sendResponse, server, statusMessages;

  fs = require('fs');

  net = require('net');

  path = require('path');

  obj = JSON.parse(fs.readFileSync('conf/local.json', 'utf8'));

  ROOT = path.join(__dirname, obj.contentFolderPath);

  console.log(ROOT);

  DEFAULT_PROTOCOL = 'HTTP/1.0';

  DEFAULT_EXTENSION = '.html';

  FIRST_LINE_REGEX = new RegExp("(GET|POST|HEAD)[ ]([\/].*[ ]){1,}HTTP\/1\.[0-9]");

  AUTHORIZED_PATH = new RegExp(ROOT + ".*");

  METHOD_REGEX = new RegExp("(GET|POST|HEAD)");

  statusMessages = {
    200: "OK",
    201: "Created",
    202: "Accepted",
    204: "No Content",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable"
  };

  contentTypeMap = {
    '.jpg': 'image/jpg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.bmp': 'image/bmp',
    '.gif': 'image/gif',
    '.js': 'application/javascript',
    '.mp4': 'video/mp4',
    '.mp3': 'audio/mp3',
    '.html': 'text/html',
    '.css': 'text/css'
  };

  createErrorHtml = function(code) {
    return {
      body: "<!DOCTYPE html> <html> <head> <title>Webserver Test</title> <meta charset='utf-8'> </head> <body> <H2>" + code + " " + statusMessages[code] + "</H2> </body> </html>"
    };
  };

  parseStatusLine = function(data) {
    var firstLine, requestLineArray, requestLineJSON;
    firstLine = (data.toString().split("\r\n"))[0];
    if (FIRST_LINE_REGEX.test(firstLine)) {
      requestLineArray = firstLine.split(" ");
      requestLineJSON = {
        method: requestLineArray[0],
        path: path.normalize(requestLineArray[1]) === '/' ? 'index.html' : requestLineArray[1],
        protocol: requestLineArray[2]
      };
      return requestLineJSON;
    } else {
      return null;
    }
  };

  createResponseHeader = function(code, ext, fileLength) {
    var responseHeader;
    responseHeader = {
      statusLine: DEFAULT_PROTOCOL + " " + code + " " + statusMessages[code],
      fields: {
        'content-Type': ext && contentTypeMap[ext] ? contentTypeMap[ext] : 'text/plain',
        'Content-Length': fileLength != null ? fileLength : 0,
        'Connection': 'close'
      }
    };
    return {
      toString: function() {
        var i, str, v, _ref;
        str = responseHeader['statusLine'] + "\r\n";
        _ref = responseHeader['fields'];
        for (i in _ref) {
          v = _ref[i];
          str += i + ': ' + v + "\r\n";
        }
        return str + '\r\n';
      }
    };
  };

  sendResponse = function(socket, header, statusCode, readStream) {
    return socket.write(header.toString(), function() {
      if (readStream) {
        return readStream.pipe(socket);
      } else {
        socket.write((createErrorHtml(statusCode))['body'] + '\n');
        return socket.end();
      }
    });
  };

  ServerOptions = {
    allowHalfOpen: false,
    pauseOnConnect: false
  };

  server = net.createServer(ServerOptions, function(socket) {
    socket.on('connection', function() {
      return console.log('socket : connect');
    });
    return socket.on('data', function(data) {
      var absolutePath, extension, responseHeader, statusCode, statusLine;
      statusCode = 400;
      statusLine = parseStatusLine(data);
      if (statusLine) {
        absolutePath = path.join(ROOT, statusLine['path']);
        extension = path.extname(absolutePath.toLowerCase());
        fs.stat(absolutePath, function(err, stats) {
          var fileSize, readStream, responseHeader;
          if (err) {
            statusCode = 404;
          } else if (stats.isDirectory() || !AUTHORIZED_PATH.test(absolutePath)) {
            statusCode = 403;
          } else if (stats.isFile()) {
            statusCode = 200;
            fileSize = stats["size"];
            readStream = fs.createReadStream(absolutePath);
            readStream.on('end', function() {
              return socket.end();
            });
          }
          if (!fileSize) {
            extension = DEFAULT_EXTENSION;
            fileSize = Buffer.byteLength((createErrorHtml(statusCode))['body'], 'utf8');
          }
          responseHeader = createResponseHeader(statusCode, extension, fileSize);
          return sendResponse(socket, responseHeader, statusCode, readStream);
        });
      } else {
        responseHeader = createResponseHeader(statusCode);
        sendResponse(socket, responseHeader, statusCode);
      }
      socket.on('error', function(err) {
        return console.log('socket: error', err);
      });
      return socket.on('close', function() {});
    });
  });

  server.listen(9000, 'localhost');

}).call(this);
