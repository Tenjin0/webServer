// Generated by CoffeeScript 1.9.0
(function() {
  var PARENTDIRECTORYREGEX, REQUESTLINEREGEX, constructHeader, contentTypeMap, dataToArray, errorHtml, extractRequestLine, findContentTypeFile, fs, isNotEmpty, net, options, path, root, server, statusCode;

  fs = require('fs');

  net = require('net');

  path = require('path');

  root = __dirname + '/webroot';

  options = {
    allowHalfOpen: false,
    pauseOnConnect: false
  };

  statusCode = {
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "204": "No Content",
    "301": "Moved Permanently",
    "302": "Moved Temporarily",
    "304": "Not Modified",
    "400": "Bad Request",
    "401": "Unauthorized",
    "403": "Forbidden",
    "404": "Not Found",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable"
  };

  contentTypeMap = {
    'image': {
      tab: ["jpg", "jpeg", "png", "bmp", "gif"]
    },
    'application': {
      tab: ['js'],
      replace: ['javascript']
    },
    'video': {
      tab: ['mp4']
    },
    'audio': {
      tab: ['mp3']
    },
    'text': {
      tab: ['html', 'css']
    }
  };

  -(errorHtml = -"<!DOCTYPE html> -<html> -<head> -	<title>Webserver Test</title> -	<meta charset='utf-8'> -</head> -<body> -	<H2>The page you trying to access was not found</H2> -</body> -</html>");

  REQUESTLINEREGEX = new RegExp("[GET|POST|HEAD][ ]([\/].*[ ]){0,1}HTTP\/1\.[0-9]");

  PARENTDIRECTORYREGEX = new RegExp("[\.]{2,}[\/].*");

  findContentTypeFile = function(ext) {
    var contentType, i, index, tab;
    if (!(ext === null)) {
      for (i in contentTypeMap) {
        tab = contentTypeMap[i];
        index = tab['tab'].indexOf(ext);
        if (index >= 0) {
          return contentType = {
            'type': i,
            'replace': tab['replace'] === void 0 ? ext : tab['replace']
          };
        }
      }
      return options = {
        'type': 'text',
        'replace': null
      };
      return options = {
        'type': 'text',
        'replace': null
      };
    }
  };

  extractRequestLine = function(data) {
    var array, requestLineArray, requestLineJSON;
    array = dataToArray(data);
    requestLineArray = array[0];
    requestLineJSON = {
      "method": requestLineArray[0],
      "path": requestLineArray[1] = requestLineArray[1] === '/' || requestLineArray[1] === null || requestLineArray[1] === '' ? 'index.html' : requestLineArray[1],
      "protocol": requestLineArray[2]
    };
    return requestLineJSON;
  };

  isNotEmpty = function(element) {
    return !(element === '');
  };

  dataToArray = function(data) {
    var array, i, _i, _ref;
    array = data.toString().split("\r\n");
    array = array.filter(isNotEmpty);
    for (i = _i = 0, _ref = array.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      array[i] = array[i].split(" ");
    }
    return array;
  };

  constructHeader = function(protocole, ext, code, lengthFile) {
    var contentExt, contentLength, contentSubType, contentType;
    contentType = findContentTypeFile(ext);
    contentSubType = contentType['replace'] === null ? 'plain' : contentType['replace'];
    contentLength = lengthFile ? "Content-Length:" + lengthFile + "\r\n" : "";
    contentExt = ext ? "Content-Type:" + contentType['type'] + '/' + contentSubType + "\r\n" : "\r\n";
    return protocole + " " + code + " " + statusCode[code] + "\r\n" + contentExt + contentLength + "Connection: close" + "\r\n" + "\r\n";
  };

  server = net.createServer(options, function(socket) {
    var closeSocket, connectSocket, connectionSocket, dataSocket, errorSocket;
    socket.on('connection', connectionSocket = function() {
      return console.log('socket : connection' + socket.remoteAddress(+':' + socket.remotePort + "\n"));
    });
    socket.on('connect', connectSocket = function() {
      return console.log('socket : connect');
    });
    socket.on('data', dataSocket = function(data) {
      var AbsolutePath, chemin, extension, requestLineHeaderJSON, tempExtension;
      requestLineHeaderJSON = extractRequestLine(data);
      chemin = requestLineHeaderJSON['path'];
      if (!PARENTDIRECTORYREGEX.test(chemin && REQUESTLINEREGEX.test(chemin))) {
        AbsolutePath = path.join(root, chemin);
        extension = (path.extname(AbsolutePath.toLowerCase())).replace('.', '');
        tempExtension = extension;
        return fs.stat(AbsolutePath, function(err, stats) {
          var headerResponse, readStream;
          if (err) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "404");
            console.log('err', err);
            socket.write(errorHtml);
            socket.end();
          } else if (stats.isFile()) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "200", stats["size"]);
            readStream = fs.createReadStream(AbsolutePath);
          } else {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "404");
          }
          socket.write(headerResponse);
          if (readStream) {
            console.log('je rentre dans le redStream');
            readStream.on('open', function() {
              console.log(requestLineHeaderJSON['method'].toUpperCase(), requestLineHeaderJSON['method'].toUpperCase() === 'GET' || requestLineHeaderJSON['method'].toUpperCase() === 'POST');
              if ((requestLineHeaderJSON['method'].toUpperCase() === 'GET') || (requestLineHeaderJSON['method'].toUpperCase() === 'POST')) {
                return readStream.pipe(socket);
              }
            });
            return readStream.on('close', function() {});
          }
        });
      }
    });
    socket.on('error', errorSocket = function() {});
    return socket.on('close', closeSocket = function() {});
  });

  server.listen(9000, 'patrice');

}).call(this);
