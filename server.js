// Generated by CoffeeScript 1.9.0

/* reference
	cookie spec : http://curl.haxx.se/rfc/cookie_spec.html
	buffer https://docs.nodejitsu.com/articles/advanced/buffers/how-to-use-buffers
 */

(function() {
  var AUTHORIZED_PATH, Cookie, DEFAULT_EXTENSION, DEFAULT_PROTOCOL, DOMAIN_NAME, ErrorHtml, FIRST_LINE_REGEX, NAME_VALUE_REGEX, REQUEST_HOST_REGEX, REQUEST_PATH_REGEX, ROOT, RequestHeader, Response, SESSION_ID, ServerOptions, SessionCookie, contentTypeMap, fs, net, path, server, statusMessages, uploadClass;

  fs = require('fs');

  net = require('net');

  path = require('path');

  uploadClass = require('./class');

  DOMAIN_NAME = uploadClass.DOMAIN_NAME;

  ROOT = uploadClass.ROOT;

  DEFAULT_PROTOCOL = uploadClass.DEFAULT_PROTOCOL;

  DEFAULT_EXTENSION = uploadClass.DEFAULT_EXTENSION;

  SESSION_ID = uploadClass.SESSION_ID;

  FIRST_LINE_REGEX = uploadClass.FIRST_LINE_REGEX;

  AUTHORIZED_PATH = uploadClass.AUTHORIZED_PATH;

  REQUEST_HOST_REGEX = uploadClass.REQUEST_HOST_REGEX;

  REQUEST_PATH_REGEX = uploadClass.REQUEST_PATH_REGEX;

  NAME_VALUE_REGEX = uploadClass.NAME_VALUE_REGEX;

  statusMessages = uploadClass.statusMessages;

  contentTypeMap = uploadClass.contentTypeMap;

  ErrorHtml = uploadClass.ErrorHtml;

  RequestHeader = uploadClass.RequestHeader;

  Cookie = uploadClass.Cookie;

  SessionCookie = uploadClass.SessionCookie;

  Response = uploadClass.Response;

  ServerOptions = {
    allowHalfOpen: true,
    pauseOnConnect: true
  };

  server = net.createServer(ServerOptions, function(socket) {
    server.getConnections(function(err, count) {
      return console.log('server connections', err, count, socket.remoteAddress, socket.remotePort, socket.remoteFamily);
    });
    socket.setEncoding('utf8');
    socket.resume();
    socket.on('data', function(data) {
      var err, match, requestHeader, response, tempData;
      if (!tempData) {
        tempData = new Buffer(data, "utf-8");
      }
      tempData.write(data, "utf-8");
      console.log('\n<<<<<<<<<< DATA >>>>>>>');
      console.log(tempData);
      if (match = data.toString().match(new RegExp("\r\n\r\n"))) {
        socket.pause();
        console.log('ca marche', data.substring(0, match.index));
        try {
          requestHeader = new RequestHeader(socket, data.substring(0, match.index));
          response = new Response();
          return response.createResponse(socket, requestHeader, function() {
            var sessionCookie;
            if (!(sessionCookie = requestHeader.getCookieSession())) {
              sessionCookie = new SessionCookie(requestHeader.getDomain());
              response.addCookie(sessionCookie);
              return response.sendResponse(socket);
            }
          });
        } catch (_error) {
          err = _error;
          console.log('error', err);
          return socket.destroy();
        } finally {
          socket.resume();
        }
      }
    });
    socket.on('error', function(err) {
      console.log('socket: error', err);
      socket.destroy();
      socket.on('open', function() {});
      return console.log('socket: open', socket.remoteAddress, socket.remotePort);
    });
    socket.on('close', function() {
      return console.log('socket: close');
    });
    socket.setTimeout(10000);
    socket.on('timeout', function() {
      console.log('socket: timeout...');
      return socket.destroy();
    });
    return server.on('error', function(err) {
      return console.log('server: error', err);
    });
  });

  server.listen(9000, DOMAIN_NAME);

}).call(this);

//# sourceMappingURL=server.js.map
