// Generated by CoffeeScript 1.9.0
(function() {
  var FindContentTypeFile, PARENTDIRECTORYREGEX, REQUESTLINEREGEX, constructHeader, contentTypeMap, dataToArray, extractRequestLine, fs, html, httpRequest, isNotEmpty, net, options, path, root, server, statusCode, testHeader;

  fs = require('fs');

  net = require('net');

  path = require('path');

  root = __dirname + '/webroot';

  options = {
    allowHalfOpen: false,
    pauseOnConnect: false
  };

  statusCode = {
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "204": "No Content",
    "301": "Moved Permanently",
    "302": "Moved Temporarily",
    "304": "Not Modified",
    "400": "Bad Request",
    "401": "Unauthorized",
    "403": "Forbidden",
    "404": "Not Found",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable"
  };

  contentTypeMap = {
    'image': {
      tab: ["jpg", "jpeg", "png", "bmp", "gif"]
    },
    'application': {
      tab: ['js'],
      replace: ['javascript']
    },
    'video': {
      tab: ['mp4']
    },
    'audio': {
      tab: ['mp3']
    },
    'text': {
      tab: ['html', 'css']
    }
  };

  REQUESTLINEREGEX = new RegExp("[GET|POST|HEAD][ ]([\/].*[ ]){0,1}HTTP\/1\.[0-9]");

  PARENTDIRECTORYREGEX = new RegExp("[\.]{2,}[\/].*");

  testHeader = "GET / HTTP/1.1";

  httpRequest = "GET / HTTP/1.0\r\n Host: patrice:3333\r\n Connection: keep-alive\r\n Cache-Control: max-age=0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/40.0.2214.111 Chrome/40.0.2214.111 Safari/537.36\r\n Accept-Encoding: gzip, deflate, sdch\r\n Accept-Language: fr-FR,fr;q=0.8,en-US;q=0.6,en;q=0.4\r\n";

  html = "<!DOCTYPE html> <html> <head> <title>Webserver Test</title> <meta charset='utf-8'> </head> <body> Ceci est le body </body> </html>";

  FindContentTypeFile = function(ext) {
    var contentType, i, index, tab;
    if (!(ext === null)) {
      for (i in contentTypeMap) {
        tab = contentTypeMap[i];
        index = tab['tab'].indexOf(ext);
        if (index >= 0) {
          return contentType = {
            'type': i,
            'replace': tab['replace'] === void 0 ? ext : tab['replace']
          };
        }
      }
      return options = {
        'type': 'text',
        'replace': null
      };
      return options = {
        'type': 'text',
        'replace': null
      };
    }
  };

  extractRequestLine = function(data) {
    var array, requestLineArray, requestLineJSON;
    array = dataToArray(data);
    requestLineArray = array[0];
    requestLineJSON = {
      "method": requestLineArray[0],
      "path": requestLineArray[1] = requestLineArray[1] === '/' || requestLineArray[1] === null || requestLineArray[1] === '' ? 'index.html' : requestLineArray[1],
      "protocol": requestLineArray[2]
    };
    return requestLineJSON;
  };

  isNotEmpty = function(element) {
    return !(element === '');
  };

  dataToArray = function(data) {
    var array, i, _i, _ref;
    array = data.toString().split("\r\n");
    array = array.filter(isNotEmpty);
    for (i = _i = 0, _ref = array.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      array[i] = array[i].split(" ");
    }
    return array;
  };

  constructHeader = function(protocole, ext, code, lengthFile) {
    var contentExt, contentLength, contentSubType, contentType;
    contentType = FindContentTypeFile(ext);
    contentSubType = contentType['replace'] === null ? 'plain' : contentType['replace'];
    contentLength = lengthFile ? "Content-Length:" + lengthFile + "\r\n" : "";
    contentExt = ext ? "Content-Type:" + contentType['type'] + '/' + contentSubType + "\r\n" : "\r\n";
    return protocole + " " + code + " " + statusCode[code] + "\r\n" + contentExt + contentLength + "Connection: close" + "\r\n" + "\r\n";
  };

  server = net.createServer(function(socket) {
    var closeSocket, connectSocket, connectionSocket, dataSocket, errorSocket;
    socket.on('connection', connectionSocket = function() {
      return console.log('socket : connection' + socket.remoteAddress(+':' + socket.remotePort + "\n"));
    });
    socket.on('connect', connectSocket = function() {
      return console.log('socket : connect');
    });
    socket.on('data', dataSocket = function(data) {
      var chemin, extension, filePath, requestLineHeaderJSON, tempExtension;
      requestLineHeaderJSON = extractRequestLine(data);
      chemin = requestLineHeaderJSON['path'];
      if (!PARENTDIRECTORYREGEX.test(chemin && REQUESTLINEREGEX.test(chemin))) {
        filePath = path.join(root, chemin);
        extension = (path.extname(filePath.toLowerCase())).replace('.', '');
        tempExtension = extension;
        return fs.stat(filePath, function(err, stats) {
          var headerResponse, readStream;
          if (err) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "404");
            console.log('err', err);
          } else if (stats.isFile()) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "200", stats["size"]);
            readStream = fs.createReadStream(filePath);
          } else {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, "404");
          }
          socket.write(headerResponse);
          readStream.on('open', function() {
            console.log(requestLineHeaderJSON['method'].toUpperCase(), requestLineHeaderJSON['method'].toUpperCase() === 'GET' || requestLineHeaderJSON['method'].toUpperCase() === 'POST');
            if ((requestLineHeaderJSON['method'].toUpperCase() === 'GET') || (requestLineHeaderJSON['method'].toUpperCase() === 'POST')) {
              return readStream.pipe(socket);
            }
          });
          return readStream.on('close', function() {});
        });
      }
    });
    socket.on('error', errorSocket = function() {});
    return socket.on('close', closeSocket = function() {});
  });

  server.listen(9000, 'patrice');

}).call(this);
