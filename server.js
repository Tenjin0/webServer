// Generated by CoffeeScript 1.9.0
(function() {
  var PARENT_DIRECTORY_REGEX, REQUEST_LINE_REGEX, chemin, constructHeader, contentType, contentTypeMap, createResponseHeader, dataToArray, ext, extension, extractRequestLine, findContentTypeFile, fs, header, html, httpRequest, isNotEmpty, net, newContentTypeMap, options, path, requestLineHeaderJSON, root, server, simpleHeader, statusCode, subType, tab, type, _i, _len, _ref;

  fs = require('fs');

  net = require('net');

  path = require('path');

  root = __dirname + '/webroot';

  options = {
    allowHalfOpen: false,
    pauseOnConnect: false
  };

  statusCode = {
    200: "OK",
    201: "Created",
    202: "Accepted",
    204: "No Content",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    304: "Not Modified",
    400: "Bad Request",
    401: "Unauthorized",
    403: "Forbidden",
    404: "Not Found",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable"
  };

  simpleHeader = "GET / HTTP/1.0";

  contentTypeMap = {
    'image': {
      tab: ["jpg", "jpeg", "png", "bmp", "gif"]
    },
    'application': {
      tab: ['js'],
      replace: ['javascript']
    },
    'video': {
      tab: ['mp4']
    },
    'audio': {
      tab: ['mp3']
    },
    'text': {
      tab: ['html', 'css']
    }
  };

  newContentTypeMap = [];

  for (type in contentTypeMap) {
    tab = contentTypeMap[type];
    _ref = tab['tab'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      subType = tab['replace'] === void 0 ? ext : tab['replace'];
      newContentTypeMap.push((newContentTypeMap[ext] = type + "/" + subType));
    }
  }

  httpRequest = "GET / HTTP/1.0\r\n Host: patrice:3333\r\n Connection: keep-alive\r\n Cache-Control: max-age=0\r\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\r\n User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/40.0.2214.111 Chrome/40.0.2214.111 Safari/537.36\r\n Accept-Encoding: gzip, deflate, sdch\r\n Accept-Language: fr-FR,fr;q=0.8,en-US;q=0.6,en;q=0.4\r\n";

  html = "<!DOCTYPE html> <html> <head> <title>Webserver Test</title> <meta charset='utf-8'> </head> <body> Ceci est le body </body> </html>";

  REQUEST_LINE_REGEX = new RegExp("[GET|POST|HEAD][ ]([\/].*[ ]){0,1}HTTP\/1\.[0-9]");

  PARENT_DIRECTORY_REGEX = new RegExp("[\.]{2,}[\/].*");

  findContentTypeFile = function(ext) {
    var contentType, i, index;
    if (!(ext === null)) {
      for (i in contentTypeMap) {
        tab = contentTypeMap[i];
        index = tab['tab'].indexOf(ext);
        if (index >= 0) {
          return contentType = {
            'type': i,
            'replace': tab['replace'] === void 0 ? ext : tab['replace']
          };
        }
      }
      return options = {
        'type': 'text',
        'replace': null
      };
      return options = {
        'type': 'text',
        'replace': null
      };
    }
  };

  extractRequestLine = function(data) {
    var array, requestLineArray, requestLineJSON;
    array = (data.split("\r\n"))[0];
    console.log('array', array);
    if (REQUEST_LINE_REGEX.test(array)) {
      JSON.stringify();
      requestLineArray = array[0];
      console.log(requestLineArray.toString());
      requestLineJSON = {
        "method": requestLineArray[0],
        "path": requestLineArray[1] = requestLineArray[1] === '/' || requestLineArray[1] === null || requestLineArray[1] === '' ? 'index.html' : requestLineArray[1],
        "protocol": requestLineArray[2]
      };
      return requestLineJSON;
    }
    return null;
  };

  isNotEmpty = function(element) {
    return !(element === '');
  };

  dataToArray = function(data) {
    var array, i, _j, _ref1;
    array = data.toString().split("\r\n");
    array = array.filter(isNotEmpty);
    for (i = _j = 0, _ref1 = array.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      array[i] = array[i].split(" ");
    }
    return array;
  };

  createResponseHeader = function(protocole, ext, code, lengthFile) {
    return {
      statusLine: protocole + " " + code + " " + statusCode[code] + "\r\n",
      contentType: "Content-Type: " + newContentTypeMap[ext] + "\r\n",
      contentLength: lengthFile ? "Content-Length: " + lengthFile + "\r\n" : void 0,
      connection: "Connection: close\r\n",
      toString: function() {
        return "" + this.statusLine + this.contentType + this.contentLength + this.connection + "\r\n";
      }
    };
  };

  constructHeader = function(protocole, ext, code, lengthFile) {
    var contentExt, contentLength, contentSubType, contentType;
    contentType = findContentTypeFile(ext);
    contentSubType = contentType['replace'] === null ? 'plain' : contentType['replace'];
    contentLength = lengthFile ? "Content-Length:" + lengthFile + "\r\n" : "";
    contentExt = ext ? "Content-Type:" + contentType['type'] + '/' + contentSubType + "\r\n" : "\r\n";
    return protocole + " " + code + " " + statusCode[code] + "\r\n" + contentExt + contentLength + "Connection: close" + "\r\n" + "\r\n";
  };

  requestLineHeaderJSON = extractRequestLine(httpRequest);

  console.log('firstLineHeaderJSON', requestLineHeaderJSON);

  chemin = requestLineHeaderJSON['path'];

  console.log('path : ', chemin);

  extension = (path.extname(chemin.toLowerCase())).replace('.', '');

  contentType = findContentTypeFile(extension);

  header = constructHeader(requestLineHeaderJSON['protocol'], extension, "200");

  console.log('headerResponse ', header);

  console.log(newContentTypeMap);

  console.log((createResponseHeader("HTTP/1.0", 'html', 200, 900)).toString());

  server = net.createServer(options, function(socket) {
    var closeSocket, connectSocket, connectionSocket, dataSocket, errorSocket;
    socket.on('connection', connectionSocket = function() {
      return console.log('socket : connection' + socket.remoteAddress(+':' + socket.remotePort + "\n"));
    });
    socket.on('connect', connectSocket = function() {
      return console.log('socket : connect');
    });
    socket.on('data', dataSocket = function(data) {
      var absolutePath, tempExtension;
      requestLineHeaderJSON = extractRequestLine(data);
      chemin = requestLineHeaderJSON['path'];
      console.log('chemin', chemin);
      if (!PARENT_DIRECTORY_REGEX.test(chemin)) {
        absolutePath = path.join(root, chemin);
        extension = (path.extname(absolutePath.toLowerCase())).replace('.', '');
        tempExtension = extension;
        return fs.stat(absolutePath, function(err, stats) {
          var headerResponse, readStream;
          if (err) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, 404);
            console.log('err', err);
          } else if (stats.isFile()) {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, 200, stats["size"]);
            readStream = fs.createReadStream(absolutePath);
          } else {
            headerResponse = constructHeader(requestLineHeaderJSON['protocol'], tempExtension, 404);
            socket.write(errorHtml);
            socket.end();
          }
          socket.write(headerResponse);
          if (readStream) {
            readStream.on('open', function() {
              if ((requestLineHeaderJSON['method'].toUpperCase() === 'GET') || (requestLineHeaderJSON['method'].toUpperCase() === 'POST')) {
                return readStream.pipe(socket);
              }
            });
            return readStream.on('close', function() {});
          }
        });
      }
    });
    socket.on('error', errorSocket = function() {});
    return socket.on('close', closeSocket = function() {});
  });

  server.listen(9000, 'localhost');

}).call(this);
